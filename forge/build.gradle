import org.gradle.api.internal.file.copy.CopyAction

plugins {
    id 'net.minecraftforge.gradle'
    id 'org.spongepowered.mixin'
    id 'org.parchmentmc.librarian.forgegradle'
}

configurations.create("includedLibraries")
configurations.create("runtimeCoreProject")
configurations.implementation.extendsFrom configurations.includedLibraries
configurations.runtimeOnly.extendsFrom configurations.runtimeCoreProject

project.addCoreProject()

project.minecraft.mappings channel: "parchment", version: "${project.parchmentMinecraftVersion}-${project.parchmentVersion}-${project.minecraftVersion}"
project.minecraft.accessTransformer = project(':scena-common').file("forge.accesstransformer.cfg")

project.minecraft.runs { runSpecContainer ->
    client { clientRun ->
        clientRun.workingDirectory project.file('run')
        clientRun.ideaModule "${rootProject.name.toLowerCase()}.${project.name.toLowerCase()}.main"
        clientRun.taskName 'Client'
        clientRun.arg "--mixin=scena.mixins.json"
        jvmArgs "-Dmixin.debug=true", "-Dmixin.debug.export=true"
        property 'mixin.env.remapRefMap', 'true'
        property 'mixin.env.refMapRemappingFile', "${projectDir}/build/createSrgToMcp/output.srg"
        mods {
            scena {
                source sourceSets.main
                source project(":scena-core").sourceSets.main
            }
        }
    }

    project.afterEvaluate {
        def paths = new HashSet<String>();
        configurations.runtimeCoreProject.copyRecursive().resolve().collect { it.absolutePath.toString() }.each {path -> paths.add(path)}

        runSpecContainer.each { runSpec ->
            runSpec.lazyToken('minecraft_classpath', () -> {
                return paths.join(File.pathSeparator)
            })
        }
    }
}



project.dependencies.minecraft "net.minecraftforge:forge:${project.minecraftVersion}-${project.forgeVersion}"
project.dependencies.annotationProcessor "org.spongepowered:mixin:${project.mixinAnnotationProcessorVersion}:processor"
project.dependencies.includedLibraries fg.deobf("com.communi-suggestu.saecularia-caudices:saecularia-caudices-forge:${project.saeculariaCaudicesVersion}") {
    jarJar.ranged(it, project.supportedSaeculariaCaudicesVersionRange)
}
project.dependencies.runtimeOnly(project(':scena-core')) {
    transitive = false
}

project.tasks.processResources.from(project(":scena-common").file("forge.accesstransformer.cfg"), (CopySpec spec) -> {
    spec.into("META-INF")
    spec.rename("forge.accesstransformer.cfg", "accesstransformer.cfg")
})
project.tasks.processResources.outputs.upToDateWhen { false }

project.mixin.config "scena.mixins.json"
project.mixin.add project.sourceSets.main, "scena.refmap.json"

////////////////
// IntelliJ Project Import
// The Mixin annotation process does not have an obfuscation source when running through the IntelliJ compiler,
// thus we have to prevent it from being activated as part of importing this Gradle project into IntelliJ.
if (System.getProperty("idea.sync.active") == "true") {
    afterEvaluate {
        tasks.withType(JavaCompile).all {
            it.options.annotationProcessorPath = files()
        }
    }
}

jarJar {
    fromRuntimeConfiguration()
    dependencies {
        include(dependency("com.communi-suggestu.saecularia-caudices:saecularia-caudices-forge"))
        include(dependency("com.communi-suggestu.saecularia-caudices:saecularia-caudices-core"))
    }
}

reobf {
    jarJar {}
}

afterEvaluate {
    tasks.jar.finalizedBy tasks.reobfJar
    tasks.jarJar.finalizedBy tasks.reobfJarJar
    tasks.reobfJarJar.enabled = true
}

tasks.jarJar.archiveClassifier.set("");
tasks.jar.archiveClassifier.set("slim");
tasks.assemble.dependsOn tasks.jarJar

